#include <stdio.h>
#include <stdlib.h>
#include <WinSock2.h>				//网络头文件
#pragma comment(lib,"ws2_32.lib")	//网络库




/*
* 打开网络库/启动网络库：只有启动了这个库，库里的函数/功能才能使用
* 忘记打开，后面所有操作都失败
* 本质：让函数的一些变量初始化（了解一下即可）
* 
* 同步与异步：
* 同步：堵塞/卡死状态，看成一个任务执行完毕才能执行下一个任务
* 异步：多个任务能同时进行
* 
* 查看WinSock2.h的文档得知网络库版本为2.2
* #define WINSOCK_VERSION MAKEWORD(2,2)
* 
*/

int main(void)
{
	//创建参数1，WORD格式获取版本
	WORD wdVersion = MAKEWORD(2,2);
	//创建参数2，定义一个结构体，用于接住网络库的一些返回的参数，供我们查看
	//LPWSADATA lwg = malloc(sizeof(WSADATA));//LPWSADATA == *WSADATA 结构体创建方式2 ，这种记得释放空间
	WSADATA wdScokMsg;
	//启动网络库
	int nRes = WSAStartup(wdVersion, &wdScokMsg);
	//判断是否启动成功、处理错误码
	if (nRes != 0)	//返回0则成功启动，否则将是错误码
	{
		//switch用参数依次与case比较，相等则执行对应case的代码，（没遇到break的话）然后继续比对，都没有的话则执行default的代码（有default的话）
		switch (nRes)
		{
		case WSASYSNOTREADY:
			printf("底层网络子系统尚未准备好进行网络通信, 系统配置问题，重启下电脑，检查ws2_32库是否存在（C盘查找ws2_32）");
			break;
		case WSAVERNOTSUPPORTED:
			printf("要使用的版本不支持,请检查版本，更新网络库");
			break;
		case WSAEPROCLIM:
			printf(" 已达到对Windows套接字实现支持的任务数量的限制，即65536个端口全用满了。请尝试关闭不必要的软件，为软件运行提供充足的资源");
			break;
		case WSAEINPROGRESS:
			printf(" 当前函数运行期间，由于某些原因造成阻塞，会返回在这个错误码。请重新启动软件");
			break;
		case WSAEFAULT:
			printf(" lpWSAData参数不是有效指针。程序员自己的问题，启动函数WSAStartup的参数2写错啦");
			break;
		}
	}
	//校验版本，若是版本不对，则会进入
	if (2 != HIBYTE(wdScokMsg.wVersion) || 2 != LOBYTE(wdScokMsg.wVersion))
	{
		//HIBYTE是高数据位的检查，即副版本号
		//LOBYTE是低数据位的检查，即主版本号

		//可以进行一个提示
		printf("网络库版本不对");
		//进入了则证明版本不对，需要关闭网络库，（不关闭不行，版本都错了还运行什么）
		WSACleanup();
		return 0;
	}
	//创建一个socket，每个SOCKET都是独一无二的，其它的SOCKET不能重复
	SOCKET socketServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	//socket函数检查返回值
	if (socketServer == INVALID_SOCKET)
	{	//进来了则说明socket创建失败
		//获取错误码,获取离它最近的函数的错误码
		int a = WSAGetLastError();

		//因为创建scoket失败了，故无需关闭scoket操作
		//关闭网络库
		WSACleanup();
		//退出程序
		return 0;
	}
	
	//创建结构体对象(C语言要加struct),bind的参数2，输入协议簇、端口号、地址
	struct sockaddr_in st;
	st.sin_family = AF_INET;			//输入协议簇（socket创建时的参数1，即地址类型）
	st.sin_port = htons(22258);			//输入端口号，因为输入的是整形，要利用htons强转成u_short
	st.sin_addr.S_un.S_un_b.s_b1 = 127;	//输入IP地址的方式1，分4次输入（因为是联合）
	st.sin_addr.S_un.S_un_b.s_b2 = 0;
	st.sin_addr.S_un.S_un_b.s_b3 = 0;
	st.sin_addr.S_un.S_un_b.s_b4 = 1;
	//st.sin_addr.S_un.S_addr = inet_addr("127.0.0.1");	//输入IP地址的方式3：一次性输入，要用函数转换成32位8字节的IP地址
	//给socket绑定地址与端口，sockaddr_in要强转成sockaddr的类型，结构体记得加struct
	int bres = bind(socketServer, (const struct sockaddr*)&st, sizeof(st));
	//判断是否绑定成功
	if (bres == SOCKET_ERROR)
	{
		//进入则证明绑定失败,获取错误码
		int a = WSAGetLastError();		//获取离它最近的函数的错误码
		//销毁套接字socket
		closesocket(socketServer);
		//关闭网络库
		WSACleanup();
		//退出程序
		return 0;
	}
	//开始监听服务器端的socket
	int lier = listen(socketServer, SOMAXCONN);
	//判断监听是否成功
	if (lier == SOCKET_ERROR)
	{
		//进入则监听失败，返回错误码
		int a = WSAGetLastError();
		//清理套接字socket
		closesocket(socketServer);
		//关闭网络库
		WSACleanup();
		//退出程序
		return 0;
	}
	//接受客户端的链接
	//创建参accept的参数
	struct sockaddr_in socketClient;
	int nLen = sizeof(socketClient);
	//将客户端的链接绑定到一个socket（套接字）上
	SOCKET Clientsocket = accept(socketServer, (struct sockaddr*)&socketClient, &nLen);
	//判断是否客户端链接绑定是否成功，进行失败处理
	if (Clientsocket == INVALID_SOCKET)
	{
		//返回错误码
		int a = WSAGetLastError();
		//清除套接字
		closesocket(socketServer);
		//关闭网络库
		WSACleanup();
		//退出程序
		return 0;
	}
	//接受客户端消息
	char buf[1500] = { 0 };	//创建字符数组，即参数2
	int res = recv(Clientsocket, buf, 1499, 0);
	if (res == 0)	//为0则是客户端下线
		printf("链接中断，客户端下线");
	else if (res == SOCKET_ERROR)
	{
		//获取错误码
		int a = WSAGetLastError();
		//根据错误码进行错误处理，一般用不上
			//可能是重启
			//可能是等待
			//可能是不用管
		//不用关闭网络库，也不必清理socket
		// 
		//因为服务端的模型已经搭建好了，只是一个客户端失败，没必要关闭整个模型
	}
	else			//没有出错，没有中断，输出消息
		printf("%d    %s", res, buf);

	//send发送函数（应该写在客户端的）
	
	int se = send(socketServer, "撑住，起床别啦！", sizeof("撑住，起床别啦！"), 0);
	if (se == SOCKET_ERROR)
	{
		//执行失败，获得错误码
		int a = WSAGetLastError();
		//然后根据实际情况处理错误码
	}
	


	//程序结束了，要关闭掉网络库	//closesocket属于网络库函数，所以要先关闭
	//先关闭套接字	
	closesocket(socketServer);
	//关闭客户端的套接字
	closesocket(Clientsocket);
	//再关闭网络库
	WSACleanup();



	system("pause>0");
	return 0;
}

void sutdy()
{
	//2.3、2.4笔记
	if (0)
	{
		/*
	*
	* WORD格式获取版本,用2.1举例，演示参数的版本如何存储（写法固定的，记下来就好）
	* WORD wdVersion = MAKEWORD(2,1);
	* WORD：F12查看文档得知是unsigned short 的重命名，2字节（每字节8位）
	*
	* 根据下面得出版本在wdVersion中的存储形式，可以分开取出主副版本号
	* 利用强转，取到第一个字节与第二个字节，先将地址变成char *（指针），然后偏移用*操作原空间
	* int a = *((char*)&wdVersion);		//取到第1个字节（低地址位，低数据位）2
	* int b = *((char*)&wdVersion+1);		//取到第2个字节（高地址位，高数据位）1
	*
	* WSAStartup(wdVersion,&wdScokMsg);
	* 参数1：要使用的版本，不能直接写2.1，因为2.1是浮点型，这里只能传递WORD
	* 参数2：LPWSADATA类型，是WSADATA类型的指针重命名，即 *WSADATA
	* 返回值：如果成功启动，返回0，否则返回一些错误码（有多种）对应的错误码在课件中介绍了，还有对应的处理方式
	*
	* 参数2：创建结构体，启动网络库后，会向结构体传递一些信息，可截断调试查看有哪些信息
	* WSADATA wdScokMsg;
	* 可写成：因为LPWSADATA 是 *WSADATA
	* LPWSADATA lwg = malloc(sizeof(WSADATA));
	* free(wdScokMsg);如果使用malloc一定要记得释放，别忘了
	*
	* 版本目前只有 1.0、 1.1、 2.1、 2.2
	* 如果输不存在的版本，有三种情况
	* 输入 0. 开头的版本，会失败
	* 输入 1. 开头的版本 会打开1为主版本的最高支持版本1.1
	* 输入 2. 开头的版本 会打开2为主版本的最高支持版本2.2
	* 输入 2以上版本，如8 会打开最高支持版本2.2
	*
	* 课件有一些我没记载的描述，记得打开对比复习
	*
	* 小端存储：
	* WORD wdVersion = MAKEWORD(2,1);让2 1 存到类型为WORD的wdVersion中
	* 截断调试查看wdVersion的值，得到258，转换成二进制为 0001 0000 0010，因为short2字节
	* 所以我们把它分成两部分，高数据位为0000 0001 低数据位为0000 0010
	* 对应着 1 2。  1是副版本号，2是主版本号，
	* 得出结论，副版本号存在高数据位，主版本号存在低数据位，注意这是数据位
	* 那内存的存储呢（计算机一般是小端存储），低数据位对应着低地址位，高数据位对应着高地址位
	* 低地址位即计算机优先取的位，比如连续空间的地址0x10 0x20.  0x10就是低地址位，往后递增
	*
	* 位运算：
	* MAKEWORD: 一个宏，实现原理是用到 1111 1111 跟对应数据位的数值 进行 与 的逻辑运算
	* 然后就得到对应位的二进制了，F12查看，0xff：1111 1111
	*  ((WORD)(((BYTE)(((DWORD_PTR)(a)) & 0xff)) | ((WORD)((BYTE)(((DWORD_PTR)(b)) & 0xff))) << 8))
	*
	*
	*
	* MSDN才是唯一标准的文档，要学会看
	*/
	}
	//2.5笔记 WSAStartup返回值的错误码处理
	if (0)
	{
		/*
		* 要会看MSDN（很重要）
		* 错误码都是一些宏
		* 每种错误对应唯一的错误码，去MSDN查看错误码是什么错误
		* 网络接口数量是一个int整型，总共有65536个端口，不可能全部用上的
		* 除非电脑配置太好，打开了很多软件，这样端口才可能出现用不过来的情况
		*/
	}
	//2.6笔记 版本校验
	if (0)
	{
		/*
		* 我们不要局限于网络函数的使用，而是应该拓展网络函数的一些通信知识
		* 函数很简单，很快就会用了
		*
		* 网络库提供了HIBYTE LOBYTE来进行高数据位，低数据位的检查
		* 配合 wdScokMsg.wVersion（当前版本）就能校验版本了
		* wdScokMsg是结构体，启动函数的参数2，网络函数会传递一些信息给结构体
		* HIBYTE是高数据位的检查，即副版本号
		* LOBYTE是低数据位的检查，即主版本号
		*
		* WSACleanup();	//关闭网络库
		* W:windows、 S：网络库、 A：异步、 Cleanup：清理
		*
		* 调试查看参数2结构体的内容
		* wVersion ： 514	当前使用的版本， 514转换成二进制是 0000 0010 0000 0010 拆分成两字节，分别为2 2 这就是我们的版本，哪个是主版本，哪个是副板本，请看2.3的笔记WORD的存储
		* wHighVersion：514 系统支持的最高版本
		* szDescription
		* szSystemStatus： 当前库的描述信息
		*
		*
		* 可改成2.1 版本来试一下是否会打印
		*/
	}
	//2.7什么是SOCKET
	if (0)
	{
		/*
		* 创建一个SOCKET
		* SOCKET socketServer = socket();
		*
		* socket()是一个函数，返回值是SOCKET类型
		* 整个底层复杂的网络协议体系，执行的流程，封装成一个函数，这个函数就是socket()
		* socket()就是我们调用协议来进行通信的操作接口
		* 复杂的网络协议过程与程序员分开，我们简单的操作一个socket()就可以了，编程层面不用考虑复杂的体系
		*
		*
		* SOCKET是一个类型，F12查看，找到重命名UINT_PTR，对其F12，发现是unsigned int
		* 即SOCKET是无符号整形的类型的重命名，记住这是类型，就像int float 等一样
		* 用于接住函数socket()的返回值
		* 这个值是唯一的，即每个socket()函数都创建了一套体系，
		* 比如创建了一个SOCKET A是TCP的协议体系，又创建了一个SOCKET B是UDP的协议体系
		* 那A有唯一对应的SOCKET返回值，B也有唯一对应的SOCKET返回值
		* SOCKET标识着当前应用程序，协议等特点，就像是门牌号，身份证号，ID
		*
		* 我们网络通信的函数，全部都要使用SOCKET
		* 每个客户端都有一个SOCKET，服务器也有一个SOCKET
		* 通信的时候，就需要SOCKET来作为参数，谁要通信，就传递谁的SOCKET
		*
		* 网络编程：理论层面SOCKET就是网络体系封装的精华
		* 代码层面：就是不停的调用SOCKET这个变量，所以又叫SOCKET编程
		* 使用SOCKET就简化了程序员编程的复杂度，减少不必要的麻烦
		*
		*/
	}
	//2.8 socker函数的参数
	if (0)
	{
		/*
		* 参数信息在MSDN上有详细介绍，还有使用例子，请学会查看MSDN，对socket按F12能查看有哪些参数
		* 参数1、2、3是配套使用的，不能乱填，TCP的有TCP的参数填法，其它协议有其他协议的填法，
		* 要使用一个协议，得看是否支持，比如蓝牙红外线，必须要有硬件支持才行
		* 协议都是国际统一规范的，可以查看技术文档，或者上网搜
		* 有一些协议是编译器没有提供的，那我们可以下载头文件或者库，包含进项目即可
		* 参数3中，有个可能这个词，所以说一般，参数3可以填写0，系统会自动帮我们选择协议类型
		*
		*
		* 不同的协议有不同的特点与应用场景，比如QQ等聊天信息，我们使用TCP，因为它数据量小，而且我们要确保他可靠，按顺序，
		* 但是如视频等，有时候看视频会卡一下，或者花屏，是因为用了UDP，视频数据量大，我们不要求多精准，
		* 那UDP因为不需要按顺序，所以效率会更高，如视频，我们传数据过去，传到了再排序，这样用UDP更合适
		* 所以不同的协议有各自的特点，不同的应用场景，这样来理解，是一种学习方法
		*
		*
		* 参数1：地址的类型
		* 比如找一个人，通过QQ，要有QQ号；通过手机，要有电话号；通过微信，要有微信号；通过地点，要有地址门牌号
		* 那这个参数就是指定地址号的类型的，比如IPv4类型，就是我们常用的128.164.1.255
		* AF_INET  2	ipv4	Internet协议版本4（IPv4）地址系列		0.0.0.0  ~  255.255.255.255
		*				4字节32位的地址  就是无符号整型int类型的范围  现在地址快不够用了
		* AF_INET6  23	ipv6	Internet协议版本6（IPv6）地址系列。	2001:0:3238:DFE1:63::FEFB
		*				16字节128位的地址		非常多的ip，几乎人类用不完，某些国家有尝试性的实验了
		* AF_BTH  32	蓝牙地址系列。	需要有蓝牙的硬件支持
		* AF_IRDA  26	红外数据协会（IrDA）地址系列。	需要有红外线硬件的支持
		*
		* 参数2：套接字类型
		* SOCK_STREAM    1		一种套接字类型，提供带有顺序、可靠的、双向、面向连接的字节流，
		*						此套接字类型使用传输控制协议TCP作为internet地址系列
		* SOCK_DGRAM    2		一种支持数据报的套接字类型，它是固定（通常很小）最大长度的无连接，不可靠的缓冲区。 此套接字类型使用用户数据报协议（UDP）作为Internet地址系列
		* SOCK_RAW   3			一种套接字类型，提供允许应用程序操作下一个上层协议头的原始套接字
		*
		*
		* 参数3：协议的类型
		* 可能的值解释，比如我们用了TCP协议的前两个固定参数，但是这里能够写TOP，或者0，因为那两个地址类型和套接字类型也支持TOP，
		* 那这样参数3可以指定为IPPROTO_TCP，也可以填0，这样会按照一个优先级来确定是TCP还是TOP
		* 前两个参数不是非常确定的决定第3个参数的类型，所以使用时要注意
		* 其它的协议类型也是如此
		* IPPROTO_TCP		传输控制协议（TCP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_STREAM时，这是一个可能的值。
		* IPPROTO_UDP		用户数据报协议（UDP）。 当af参数为AF_INET或AF_INET6且类型参数为SOCK_DGRAM时，这是一个可能的值。
		* IPPROTO_ICMP		Internet控制消息协议（ICMP）。 当af参数为AF_UNSPEC，AF_INET或AF_INET6且类型参数为SOCK_RAW或未指定时，这是一个可能的值。
		*
		*/
	}
	//2.9 socket函数返回值介绍
	if (0)
	{
		/*
		* socket创建成功返回可用的SOCKET，失败返回INVALID_SOCKET（一个宏）F12查看发现是：(SOCKET)(~0)
		* 程序结束时，一定要销毁套接字socket和网络库
		* 由于socket属于网络库，所以先关闭
		*
		* //获取错误码：
		* int a = WSAGetLastError();
		* WSAGetLastError();可以检查所有网络库的函数
		* 检查谁，就看离它最近的函数是谁（在它上面的，因为程序由上向下执行）
		* 一般放到检查中，因为只有出错了才有错误码
		* 去MSDN查看对应函数的错误是什么错误
		*
		* 故意把参数3写错，返回了10043，
		* 在菜单栏工具-错误查找，输入错误码，能查看对应的错误
		*/
	}
	//2.10 bind 绑定地址与端口 及参数讲解
	if (0)
	{
		/*
		* bind作用：
		*	给我们创建的socket绑定端口号与具体地址
		*		地址：找到我们的电脑，如IP，我们的电脑只有一个
		*		端口号：找到我们电脑上对应的软件，如QQ等
		*				每一种通信对应的端口号是唯一的
		*				有的软件功能多，占用多个端口号
		*	所有数据都通过IP-找到电脑-再通过端口号-找到对应软件
		*
		*	课件中有介绍IP地址的查看，端口号的检查与范围（1024~65535），检查端口号的占用情况
		*
		*	IP是我们机器的地址，端口就是我们具体的软件的通信口，一个软件可能会占用多个接口，比如一个软件可以聊天，可以下载，可以看视频..
		*	那么这些不同的通信内容，往往会有各自的协议，各自的端口。
		*
		*	MSDN的bind函数使用例子：
		*				iResult = bind(ListenSocket, (SOCKADDR *) &service, sizeof (service));
		*		参数2进行了强转，就是为了将sockaddr_in强转成sockaddr
		*
		*
		* 参数1：就是我们创建的socket，通信体系
		*		我们就是通过bind给socket绑定地址和端口号的
		*
		* 参数2：一个结构体
		*		结构体中：有地址的类型、IP地址、端口号
		*
		* 参数3：参数2的类型大小 sizeof(参数2)
		*
		*
		* 参数2详解：
		*		MSDN查看，有两个结构体类型供我们使用，两个结构体能相互转换
		*	struct sockaddr {
		*		ushort  sa_family;
		*		char    sa_data[14];
		*		};
		*
		*	struct sockaddr_in {
		*		short   sin_family;
		*		u_short sin_port;
		*		struct  in_addr sin_addr;
		*		char    sin_zero[8];
		*		};
		*		sockaddr的两个成员分别是：协议族（地址类型,2.8课笔记的参数1）、端口号和地址	内存大小为：ushort（2字节）char[14]（数组14字节）,总共16字节（按最大的基本类型ushort为单位分段）
		*				它将端口号和地址合在一起装到数组中，但我们不太清楚排布情况，不好使用
		*		sockaddr_in的成员分别是：协议族（地址类型，跟socket函数参数1是一样的）、端口号、IP地址（结构体类型）、填充的数组（为了与sockaddr的内存大小对应上）
		*				它的内存情况是：short（2字节），u_short（2字节），struct（IP地址为32位4字节），8字节数组（填充作用）
		*				刚好与sockaddr的内存对应上，就可以相互转换了
		*		由此得知，sockaddr_in是系统给我们提供的更明了的形式
		*
		*		端口号输入整形，需要强转成u_short：如 htons(27015);
		*
		*		sockaddr_in的第3个成员IP地址结构体是一个联合：
		*		struct in_addr {		//联合的特性是所有成员共用一个首地址
		*			union {				//所以有三种输入方式
		*			struct {
		*				u_char s_b1;	//可以用4个u_char分别输入IP地址
		*				u_char s_b2;
		*				u_char s_b3;
		*				u_char s_b4;
		*			} S_un_b;
		*			struct {
		*				u_short s_w1;	//可以用2个u_short输入地址
		*				u_short s_w2;
		*			} S_un_w;
		*			u_long S_addr;		//也可以用1个u_long来输入地址，需要强转，如service.sin_addr.s_addr = inet_addr("127.0.0.1");
		*			} S_un;
		*		};
		*
		*/
	}
	//2.11 bind函数返回值
	if (0)
	{
		/*
		* 成功绑定则返回0，失败则返回SOCKET_ERROR
		*
		* 先关闭套接字
		* closesocket(socketServer);
		* 再关闭网络库
		* WSACleanup();
		*
		* 上述的如果顺序错误，我们获取错误码得到： 10093
		* 查询得到：应用程序没有调用 WSAStartup，或者 WSAStartup 失败。
		*
		* 我们对bind返回值SOCKET_ERROR 按F12看到
		* #define INVALID_SOCKET  (SOCKET)(~0)
		* #define SOCKET_ERROR            (-1)
		*
		* (SOCKET)(~0)讲解：
		* 0按位取反，二进制是32个1，得到-1，但SOCKET是无符号整形
		* 结果得到int的最大值
		*/
	}
	//2.12 listen函数的应用
	if (0)
	{
		/*
		* 作用：让套接字处于正在侦听转入的连接的状态
		* 即理解为在监视有哪些连接的请求
		*
		* 参数1： 服务器端的socket，就是说，这个listen是用服务器端的socket创建的
		*		 注意是服务端，即服务器端，不是用户端
		*
		* 参数2：挂起连接队列的最大长度
		*		比如有100个用户请求连接，但是服务器只能一次处理20个
		*		那就会将剩下的80个用户链接请求，创建一个队列储存起来（队列特点：先进先出）
		*		等那20个用户处理完了，再来从队列中取请求来处理
		*		那创建的队列申请多大空间呢，就是这个参数的作用：确定创建的休息区队列的空间大小
		*		一般填一个宏：SOMAXCONN MSDN上说，这个参数会创建一个系统能接受的最大值，即让系统自己判断
		*		我们也可以自己设定，微软还提供了一个参数，但是移植性不好，仅微软支持，如scanf_s一样
		*
		* WSAAPI：调用约定
		*		与程序员无关，是给系统看的
		*		它的作用：函数名字的编译方式（即汇编生成二进制，如何去生成）、参数的入栈顺序、函数的调用时间
		*
		* 返回值：成功返回0
		*		失败返回SOCKET_ERROR
		*		失败了我们要设定：返回错误码（用WSAGetLastError函数）（可选）、清除套接字、关闭网络库
		*
		*/
	}
	//2.13 accept函数
	if (0)
	{
		/*
		* accept函数作用：
		*		将listen中服务端接收到的客户端链接，与一个新的socket绑定，并返回SOCKET
		*		就是listen监听客户端的链接，accept将客户端链接绑定到一个socket上
		*		也就是创建一个socket，通过返回值给我们返回客户端的SOCKET
		*		一次只能处理一个，即只能一次创建一个客户端socket
		*
		* 参数1：我们自己手动创建的socket，即服务端的socket
		*		因为我们的socket处于监听状态，后来接收到的客户端信息，都由我们创建的socket管理
		*		那我们取客户端信息，就是通过我们创建的socket来取
		*
		* 参数2：客户端的端口号与地址的结构体
		*		与bind的第2个参数一样的结构体
		*		不同的是，这是由系统自动来向这个结构体中传递客户端的端口号，地址，地址类型
		*		所以我们创建好结构体，不用赋值，系统要向里面传递客户端信息
		*
		* 参数3：参数2的字节大小
		*
		* 返回值：成功则返回客户端信息新创建好的socket，即SOCKET
		*		失败则返回INVALID_SOCKET，要进行失败处理
		*
		* 注意：程序结束时，一定要把客户端的socket也给清理掉
		*
		* 补充：参数2、参数3可以填成NULL
		*		这样的话，就是不直接获得客户端地址与端口号
		*		要获取的话，就需要用到函数：getpeername()	参数与accept一样
		*		想要获取本地的地址与端口号的函数：getsockname()
		*
		*		补充的演示如下：
		*struct sockaddr_in socketClient;									//创建结构体
		*int nLen = sizeof(socketClient);									//创建结构体大小
		*SOCKET Clientsocket = accept(socketServer,NULL,NULL);				//客户端信息绑定socket，参数2、3设为NULL
		*getpeername(Clientsocket, (struct sockaddr*)&socketClient, &nLen);	//获取到客户端的信息
		*
		*		(struct sockaddr*)不用加const，因为是函数向结构体传信息，而不是从结构体取信息
		*
		* getsockname()的参数：参数1可以随便填（只要是socket），参数2、3与函数getpeername的一样
		*		获取本地的信息
		*
		*		127.0.0.1 就是本地地址：本地环回的地址
		*/
	}
	//2.14 accept调试及特点
	if (0)
	{
		/*
		* accept特点：（重要，要记住）
		*		1.阻塞、同步：如果没有收到客户端链接，则会一直卡在那，一直等待，不往下执行程序，直到有客户端链接
		*		2.多个链接：单个accept执行，只能处理一个客户端，执行完就向下执行了，不管有没有其它客户端链接
		*					所以要想处理多个链接，就用循环来让accept重复执行，但注意循环次数必须与客户端数量一致，比如5个就5次循环
		*					返回值就用一个数组或类似的来存储
		*					因为accept要是多执行了一步，就会因为同步属性，一直卡着等待链接，程序无法向下执行
		*		3.缺点：就是2所描述的accept不能多执行，否则会死卡住，
		*				解决方法：
		*						1.多线程，一个线程放accept，另一个线程放收发信息，这样因为两个线程无法相互干扰，就解决了
		*						2.后面要学的网络模型，就已经定义好如何处理这类复杂问题了
		*/
	}
	//2.15 recv函数的使用和本质
	if (0)
	{
		/*
		* 与客户端 收发消息：
		*
		*	recv：
		*		作用：得到客户端（参数1）发送过来的消息
		*			 阻塞、同步：与accept一样
		*		本质： 复制
		*				客户端通过协议发送过来一组消息，服务端随时监听着客户端链接情况
		*				检索到客户端链接，TCP协议socket底层会创建一块协议缓冲区，将受到的消息存放进这块缓冲区
		*				然后等到调用recv时，将缓冲区的信息复制到recv创建的数组空间中，就是复制到参数2中，复制参数3的大小
		*				这也是TCP的好处，因为光是recv是不知道什么时候发，什么时候接的，利用协议本身的缓冲区，就解决了这个问题
		*				每个socket都对应自己的协议缓冲区
		*
		*	参数1：客户端的socket，即目标的socket，每个客户端对应唯一的socket
		*
		*	参数2：客户端消息的存储空间，就是一个字符数组
		*			一般这个字符数组为1500，因为网络传输的最大单元是1500字节
		*			就是说客户端发过来的信息一次最大1500字节，这是协议规定的
		*			协议规定也是根据很多数值的考察计算得出的最优值
		*			老师还说填1024也很好，符合计算机存储的规律，可能效率有一点提升
		*			对于客户端而言，一组最多1500字节，服务端一次读取1500很够了
		*
		*	参数3：想要读取的字节数
		*			一般是参数2的字节数-1 ，因为字符串结尾有\0 的结束标识符
		*
		*	参数4：数据的读取方式
		*			先填0 ，详情下节课有说
		*
		*	返回值：能读出来的字节大小
		*			客户端下线，则返回0，  需要释放客户端的socket
		*			执行失败，返回SOCKET_ERROR，可进行错误处理
		*			如果没有内容能够读取，则会阻塞住，卡住，同步，等待客户端发来消息
		*/
	}
	//2.16 revc 参数4详解
	if (0)
	{
		/*
		*	//C3老师花了大量时间上网找，才推敲出0的原理逻辑
		*	等客户端也搭建好，可以测试一下
		*	0：
		*		基本都是用0作为参数，写0就行了
		*		revc从协议缓冲区取数据，复制完一段，则会删除掉缓冲区的那一段
		*		好处1：把缓冲区读完的删掉，就可以接着读剩下的内容了，否则将会重复读取同一段内容
		*		好处2：可以计数读到了多少字节
		*		比如：存入abcdefg 第一次复制abc ，读完后，删掉缓冲区的abc，就能接着读cdefg了，否则将重复读取abc
		*		老师的演示比如abcdefgh，分三段读取， 先读abc读到了，再读def读到了，再度得到了ghf 因为没删除，f还存在字符数组中
		*		所以分段读，每次读完可以清空初始化一下字符数组
		*
		*	MSG_PEEK：
		*		窥视客户端传入的数据，将数据复制到协议缓冲区，但不会删除输入队列的数据
		*		不建议使用，会读到相同的数据，每次读都读到相同数据
		*		缺点：读数据不行、无法计数。
		*
		*	MSG_OOB：
		*		带外数据：
		*		就是传输一段数据，再外带一个特殊数据（1字节）
		*		有点像从数据中插入隐藏的神秘信息的感觉
		*		就是数据分成了两部分，一部分是正常数据，一部分是间隔插入的特殊数据
		*		不建议使用，计算机分析数据时还要将它们分开，浪费资源
		*		要实现两段数据传输，用0参数，分两段从客户端send就行了
		*		是一种协议规范
		*
		*	MSG_WAITALL：
		*		直到协议缓冲区满足参数3所请求的字节数，才能开始读取
		*		有一定作用
		*		就是传入的数据要填满参数3制定的字节大小，recv才能够读取，否则读取不了，一直卡着等待
		*
		*	等客户端搭建完成，可以自己测试一下
		*/
	}
	//2.17 send函数的使用与原理
	if (0)
	{
		/*
		* send作用：
		*		向目标发送数据
		* 本质：
		*		将输入的数据，复制到协议发送缓冲区（服务端，即接收端有协议缓冲区，与这个不一样，这个是发送的缓冲区）
		*		然后计算机伺机发送出去，伺机：比如在同一时间有其他的数据在发送，需要等待（非常快，一包数据的发送很快很快）
		*
		* 参数1：
		*		目标的socket，每个客户端对应唯一的socket
		*
		* 参数2：
		*		给对方发送的字节串
		*		不要超过1500字节（数据+包头+包尾 <= 1500）
		*			发送的时候，协议会给数据进行包装，加上协议信息，也叫协议头，包头
		*			这个包头的字节数不同的协议是不一样的，链路层14字节，ip头20字节，tcp头20字节
		*			还有包尾，包尾是状态确认，
		*			大体懂这个意思就好
		*			所以我们一般设定为2的n次方，比如1024，最多设定为1400就差不多了
		*		如果输入数据超过1500的处理方式
		*			系统会进行分片处理
		*				比如2000字节，分成两个包，第一个包加上包头包尾==1500
		*				然后第二个包也加上包头包尾，然后分成两个包来发送
		*			缺点：效率低，因为系统还要分片，装包，接受端要拆包，再结合，效率低
		*				有的协议会将第二个包直接丢掉，就造成了丢包
		*
		* 参数3：
		*		要发送的字节个数：一般2的n次方，比如1024，符合计算机存储规律，最多1400差不多了
		*		实际应用根据需求来，比如一些聊天评论啥的，可以给少一点
		*
		* 参数4：
		*		0：写0就可以了，参考recv的参数4
		*		MSG_OOB：带外数据，参考recv，一样的。
		*		MSG_DONTROUTE：指定数据不受路由限制，Windows套接字服务提供程序可以选择忽略此标志。
		*			路由：参考通信知识里的路由，还有路由表的知识
		*
		* 返回值：
		*		成功发送则返回发送的字节数
		*		执行失败返回SOCKET_ERROR，进行错误处理
		*
		*/
	}
	//2.18 客户端与服务端搭建
	if (0)
	{
		/*
		* 服务端：
		*		1.添加网络头文件，添加网络库
		*		2.打开网络库
		*		3.校验版本
		*		4.创建SOCKET		（服务器的SOCKET）
		*		5.socket绑定端口与地址
		*		6.开始监听
		*		7.创建客户端的socket/接受连接
		*		8.与客户端收发消息
		*
		* 客户端：
		*		1.添加网络头文件、网络库
		*		2.打开网络库
		*		3.校验版本
		*		4.创建SOCKET		（服务端的SOCKET，在客户端使用的服务端SOCKET）
		*		5.连接到服务器
		*		6.与服务器收发消息
		*
		* 客户端的5 连接到服务器
		*	connect:
		*		作用：链接服务器并把服务器信息与服务器socket绑定到一起
		*		参数1：服务器socket
		*		参数2：服务器Ip地址端口号结构体
		*		参数3：参数2结构体大小
		*		返回值，成功返回0 失败返回SOCKET_ERROR
		*
		*/
	}
	//2.19 完善一下最基本的C/S的模型
	if (0)
	{
		/*
		* 加上一个循环，完善一下
		*		用scanf输入
		*		使服务端与客户端能够相互你一句我一句的通话
		*		但只能这边来一句，那边来一句的顺序
		*
		* 问题：
		*		由于accep和recv是阻塞的（同步），做一件事，另一件事就做不了，只能干等
		*		结果：咱们在这等收消息recv，结果来了个链接请求，那就无法处理，链接只能accept
		*		另外，我们等的socket可能没有发请求，那我们完了
		*		从而，我这个服务器，就是废了
		*
		* 解决思考：
		*		我们直接主动跟系统要，要什么？要有请求的socket，哪个有请求了，就给我哪个
		*		得到链接请求，我们就直接accept得到是发来了消息，我们就recv
		*		从而就不会发生无谓的傻等情况
		*
		* select模型：
		*		select就是挑选的意思，它把请求的套接字给我们选出来，我们直接就去处理这些套接字
		*		即：select就是处理accept与recv阻塞问题的
		*/
	}

}